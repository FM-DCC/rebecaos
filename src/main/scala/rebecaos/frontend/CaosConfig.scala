package rebecaos.frontend

import caos.frontend.Configurator.*
import caos.frontend.{Configurator, Documentation}
import caos.view.*
import caos.sos.SOS
import rebecaos.backend.*
import rebecaos.backend.Semantics.*
import rebecaos.syntax.Program.System
import rebecaos.syntax.{Program, Show}

/** Object used to configure which analysis appear in the browser */
object CaosConfig extends Configurator[St]:
  val name = "Animator of Rebeca's semantics"
  override val languageName: String = "Input Rebeca program"

  /** Parser, converting a string into a System in rebecaOS */
  val parser =
//    str => (rebecaos.syntax.Parser.parseProgram(str),Map())
    str => initSt(rebecaos.syntax.Parser.parseProgram(str))

  /** Examples of programs that the user can choose from. The first is the default one. */
  val examples = List(
    "sandbox" -> "reactiveclass Example {\n\tknownrebecs { Example ex;}\n\tstatevars { int counter; }\n\tmsgsrv initial() {\n    counter=0;\n    aaaa = new Example(self):();\n    bbb = new Example(ex):();\n    ex.add(0);\n    }\n\tmsgsrv add(int a) {\n\t\tif ( counter < 100) \n\t\t\t{counter = counter + 1;}\n  }\n}\n\nmain {\n\tExample ex1( ex2):();\n\tExample ex2( ex1):();\n}"
      -> "",
    "Sarir-basic" -> "reactiveclass Example {\n\tknownrebecs { Example ex;}\n\tstatevars { int counter; }\n\tmsgsrv initial() {\n    counter=0;\n    ex.add(0);}\n\tmsgsrv add(int a) {\n\t\tif ( counter < 100) \n\t\t\t{counter = counter + 1;}\n  }\n}\n\nmain {\n\tExample ex1( ex2):();\n\tExample ex2( ex1):();\n}"
      -> "Simple example of a Rebeca program, taken from the Sarir paper.",
    "Prod-Cons" -> "reactiveclass Producer {\n\tknownrebecs {\n\t\tConsumer consumer;\n\t}\n\tstatevars {\n\t\tbyte p;\n\t}\n\tmsgsrv initial() {\n\t\tself.produce();\n\t}\n\tmsgsrv produce() {\n\t\t// produce data\n\t\tp=?(1,2,3,4);\n\t\tconsumer.consume(p);\n\t\tself.produce();\n\t}\n}\n\nreactiveclass Consumer {\n\tknownrebecs {\n\t}\n\tstatevars {\n\t\tbyte p;\n\t}\n\tmsgsrv initial() {\n\t}\n\tmsgsrv consume(byte data) {\n\t\t// consume data\n\t\tp = data;\n\t}\n}\n\nmain {\n\tProducer producer(consumer):();\n\tConsumer consumer():();\n}"
      -> "Producer-consumer example from FMCO 2006's paper from Marjan Sirjani",
    "Prod-Cons (dyn)" -> "reactiveclass Producer {\n\tknownrebecs {\n\t\tConsumer consumer;\n\t}\n\tstatevars {\n\t\tbyte p;\n    Producer newProducer;\n\t}\n\tmsgsrv initial() {\n\t\tself.produce();\n\t}\n\tmsgsrv produce() {\n\t\t// produce data\n\t\tp=?(1,2,3,4);\n    if (p==3) {\n\t\t\tnewProducer = new Producer(consumer):();\n    }\n    consumer.consume(p);\n\t\tif(p!=4){\n    \tself.produce();\n    }\n\t}\n}\n\nreactiveclass Consumer {\n\tknownrebecs {\n\t}\n\tstatevars {\n\t\tbyte p;\n\t}\n\tmsgsrv initial() {\n\t}\n\tmsgsrv produce(byte data) {\n\t\t// consume data\n\t\tp = data;\n\t}\n}\n\nmain {\n\tProducer producer(consumer):();\n\tConsumer consumer():();\n}"
      -> "(Unsupported) Dynamic version of the producer-consumer example from FMCO 2006's paper from Marjan Sirjani",
    "Timed-ticket" -> "reactiveclass TicketService {\n  knownrebecs {\n    Agent a;\n  }\n  statevars {\n    int issueDelay;\n  }\n  msgsrv initial(int myDelay) {\n    issueDelay = myDelay;\n  }\n  msgsrv requestTicket() {\n    delay(issueDelay);\n    a.ticketIssued (1);\n  }\n}\nreactiveclass Agent {\n  knownrebecs {\n    TicketService ts;\n    Customer c;\n  }\n  msgsrv requestTicket() {\n    ts.requestTicket()\n      deadline (5);\n  }\n\n  msgsrv ticketIssued(byte id) {\n    c.ticketIssued(id);\n  }\n}\nreactiveclass Customer {\n  knownrebecs {\n    Agent a;\n  }\n  msgsrv initial() {\n    self.try();\n  }\n  msgsrv try() {\n    a.requestTicket();\n  }\n  msgsrv ticketIssued(byte id) {\n    self.try() after(30);\n  }\n}\nmain {\n  Agent a(ts, c):();\n  TicketService ts(a):(3);\n  Customer c(a):();\n}"
      -> "Ticket Service from an SCP'25 paper on Timed Rebeca",
    "Untimed-ticket" -> "reactiveclass TicketService {\n  knownrebecs {\n    Agent a;\n  }\n  statevars {\n  }\n  msgsrv initial() {\n  }\n  msgsrv requestTicket() {\n    a.ticketIssued (1);\n  }\n}\nreactiveclass Agent {\n  knownrebecs {\n    TicketService ts;\n    Customer c;\n  }\n  msgsrv requestTicket() {\n    ts.requestTicket();\n  }\n\n  msgsrv ticketIssued(byte id) {\n    c.ticketIssued(id);\n  }\n}\nreactiveclass Customer {\n  knownrebecs {\n    Agent a;\n  }\n  msgsrv initial() {\n    self.try();\n  }\n  msgsrv try() {\n    a.requestTicket();\n  }\n  msgsrv ticketIssued(byte id) {\n    self.try();\n  }\n}\nmain {\n  Agent a(ts, c):();\n  TicketService ts(a):();\n  Customer c(a):();\n}"
      -> "Untimed version of the ticket service from an SCP'25 paper on Timed Rebeca",
    "Dining Philosophers" -> "reactiveclass Philosopher(3)\n{\n  knownrebecs\n  {\n    Fork forkL;\n    Fork forkR;\n  }\n  statevars\n  {\n    boolean eating;\n    boolean fL;\n    boolean fR;\n  }\n  msgsrv initial()\n  {\n    fL = false;\n    fR = false;\n    eating = false;\n    self.arrive();\n  }\n\n  msgsrv arrive()\n  {\n    forkL.request();\n  }\n\n  msgsrv permit()\n  {\n    if (sender == forkL) {\n      if (!fL) {\n        fL = true;\n        forkR.request();\n      }\n    }\n    else {\n      if (fL && !(fR)) {\n        fR = true;\n        self.eat();\n      }\n      // else discard the message\n    }\n  }\n\n  msgsrv eat()\n  {\n    eating = true;\n    self.leave();\n  }\n\n  msgsrv leave()\n  {\n    fL = false;\n    fR = false;\n    eating = false;\n    forkL.release();\n    forkR.release();\n    self.arrive();\n  }\n}\n\nreactiveclass Fork(3)\n{\n  knownrebecs\n  {\n    Philosopher philL;\n    Philosopher philR;\n  }\n  statevars\n  {\n    boolean lAssign;  \n    boolean rAssign;  \n    boolean leftReq;\n    boolean rightReq;\n  }\n  msgsrv initial()\n  { \n    lAssign = false;\n    rAssign = false;\n    leftReq = false;\n    rightReq = false;\n  }\n\n  msgsrv request()\n  {\n    if (sender == philL) {\n      if (!leftReq) {\n        leftReq = true;\n        if (!rAssign) {\n          lAssign = true;\n          philL.permit();\n        }\n      } \n      // else discard message\n    }\n    else {\n      if (!rightReq) {\n        rightReq = true;\n        if (!lAssign) {\n          rAssign = true;\n          philR.permit();\n        }\n      }\n      // else discard message\n    }\n  }\n  msgsrv release()\n  {\n    if (sender == philL && lAssign){\n      leftReq = false;\n      lAssign = false;\n      if (rightReq) {\n        rAssign=true;\n        philR.permit();\n      }\n    }\n    if (sender == philR && rAssign){\n      rAssign = false;\n      rightReq = false;\n      if (leftReq) {\n        lAssign=true;\n        philL.permit();\n      }\n    }\n  }\n}\n\nmain\n{\n  Philosopher phil0(fork0, fork2):();\n  Philosopher phil1(fork0, fork1):();\n  Philosopher phil2(fork1, fork2):();\n\n  Fork fork0(phil0, phil1):();\n  Fork fork1(phil1, phil2):();\n  Fork fork2(phil2, phil0):();\n}"
      -> "Dining philosophers, taken from http://rebeca-lang.org/Rebeca.",
    "Trains" -> "reactiveclass BridgeController(5) {\n  knownrebecs {\n    Train t1;\n    Train t2;\n  }\n\n  statevars {\n    boolean isWaiting1;\n    boolean isWaiting2;\n    boolean isOnBridge1;\n    boolean isOnBridge2;\n  }\n\n  msgsrv initial() {\n    isOnBridge1 = false;  // red\n    isOnBridge2 = false;  // red\n    isWaiting1 = false;\n    isWaiting2 = false;\n  }\n  \n  msgsrv Arrive() {\n    if (sender == t1){\n      if (isOnBridge2 == false) {\n        isOnBridge1 = true; // green\n        t1.YouMayPass();\n      }\n      else {\n        isWaiting1 = true;\n      }\n    }\n    else {\n      if (isOnBridge1 == false){\n        isOnBridge2 = true; // green\n        t2.YouMayPass();\n      }\n      else{\n        isWaiting2 = true;\n      }\n    }\n  }\n  \n  msgsrv Leave() {\n    if (sender == t1) {\n      isOnBridge1 = false;  // red\n      if (isWaiting2){\n        isOnBridge2 = true;\n        t2.YouMayPass();\n        isWaiting2 = false;\n      }\n    } else {\n      isOnBridge2 = false;  // red\n      if (isWaiting1) {\n        isOnBridge1 = true;\n        t1.YouMayPass();\n        isWaiting1 = false;\n      }\n    }\n  }\n}\n\nreactiveclass Train(3) {\n  knownrebecs {\n    BridgeController controller;\n  }\n\n  statevars {\n    boolean onTheBridge;\n  }\n\n  msgsrv initial() {\n    onTheBridge = false;\n    self.Passed();\n  }\n\n  msgsrv YouMayPass() {\n    onTheBridge = true;\n    self.Passed();\n  }\n  \n  msgsrv Passed() {\n    onTheBridge = false;\n    controller.Leave();\n    self.ReachBridge();\n  }\n\n  msgsrv ReachBridge() {\n    controller.Arrive();\n  }\n}\n\nmain {\n  Train train1(theController):();\n  Train train2(theController):();\n  BridgeController theController(train1, train2):();\n}"
      -> "Two trains and a controller, taken from http://rebeca-lang.org/Rebeca.",
    "Leader Election HS (fix)" -> "reactiveclass Node(8) { \n    knownrebecs { \n\t    Node nodeL; \n        Node nodeR; \n    } \n      \n    statevars { \n        boolean monitor; \n        int myId; \n        int phase; \n        int monitorId; \n        boolean receivedLeft; \n        boolean receivedRight; \n    } \n  \n    msgsrv initial(int id) { \n        myId = id; \n        monitor = false; \n        monitorId = id; \n        phase = 1; \n        receivedLeft = false; \n        receivedRight = false; \n        self.arrive(); \n    } \n  \n    msgsrv arrive() { \n        nodeL.receive(myId, true, phase); \n        nodeR.receive(myId, true, phase); \n\t} \n  \n\tmsgsrv receive(int msgId, boolean inOut, int hopCount) { \n\t\tif ((sender==nodeL) &&  (inOut)) {\n\t\t\tif (((msgId <monitorId)||(msgId==monitorId)) && (hopCount >1)) { \n\t\t\t\tmonitorId = msgId; \n        \t    nodeR.receive (msgId, true, hopCount-1); \n            } else { \n\t\t\t\tif (((msgId <monitorId)||(msgId==monitorId)) && (hopCount ==1)){ \n\t\t\t\t\tmonitorId=msgId; \n                    nodeL.receive (msgId, false,1); \n                } else { \n                    if (msgId == myId) { \n                    \tmonitor = true; \n                    \tmonitorId = myId; \n                \t} \n                } \n\t\t\t} \n        } \n            \n        if ((sender==nodeR) && (inOut)) { \n\t\t\tif (((msgId <monitorId)||(msgId==monitorId)) && (hopCount >1)){ \n            \tmonitorId=msgId; \n                nodeL.receive (msgId, true, hopCount-1); \n            } else { \n\t\t\t\tif (((msgId <monitorId)||(msgId==monitorId)) && (hopCount ==1)){  \n                \tmonitorId=msgId; \n\t\t\t\t\tnodeR.receive (msgId, false,1); \n                } else { \n                \tif (msgId == myId) { \n                    \tmonitor = true; \n                        monitorId = myId; \n                    } \n                } \n        \t} \n        } \n            \n        if ((sender==nodeL) && !(inOut) && !(msgId==myId)) { \n        \tnodeR.receive(msgId, false, 1);           \n        } \n            \n        if ((sender==nodeR) &&  !(inOut) && !(msgId==myId)) { \n        \tnodeL.receive(msgId, false, 1);           \n        } \n            \n\t\tif ((sender==nodeL) && !(inOut) && ((msgId == myId) && (hopCount==1))) { \n        \treceivedLeft = true; \n        } \n\t\tif (((sender==nodeR) && (msgId == myId)) && !(inOut) && (hopCount==1)) { \n        \treceivedRight = true; \n        }     \n            \n        if (receivedLeft && receivedRight&& (phase<3)){ \n        \tif(phase==2) { \n            \tmonitor=true; \n            } else { \n                phase = phase * 2; \n                receivedLeft=false; \n                receivedRight=false; \n                nodeL.receive(myId, true, phase); \n                nodeR.receive(myId, true, phase); \n            } \n        } \n\t} \n} \n  \n  \nmain { \n      Node node1(node4,node2):(1); \n      Node node2(node1,node3):(2); \n      Node node3(node2,node4):(3); \n      Node node4(node3,node1):(4); \n} "
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Leader Election LCR" -> "reactiveclass Node(8){\n\tknownrebecs {\n\t\tNode rightNode;\n\t}\n\tstatevars {\n\t\tboolean isLeader;\n\t\tint myNumber;\n\t\tint currentLeader;\t\t\n\t}\n\tmsgsrv initial(int n) {\n\t\tmyNumber = n;\n\t\tcurrentLeader = n;\n\t\tisLeader = false;\n\t\tself.send();\n\t}\n\t\n\tmsgsrv ImLeader() {\n\t\tself.ImLeader();\n\t\t//The algorithm terminates here, but the leader keeps sending a msg to himself to avoid deadlock.\n\t}\n\tmsgsrv send() {\n\t\trightNode.receive(currentLeader);\n\t}\n\tmsgsrv receive(int n) {\n\t\tif (n == myNumber) {\n\t\t\tisLeader = true;\n\t\t\tself.ImLeader();\n\t\t}\n\t\telse {\n\t\t\tif (n > currentLeader) {\n\t\t\t\tcurrentLeader = n;\n\t\t\t\tself.send();\n\t\t\t}\n\t\t\t//else discard\n\t\t}\n\t}\n}\n\nmain { \n//Each node must have a unique identifier\n//In case of having more than three nodes or changing the leader to other node (rather than node1), you should change the property file too.\n   Node node0(node2):(4); \n   Node node1(node0):(20); \n   Node node2(node1):(10); \n} "
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "2-phase commit (array)" -> "//2 Phase Commit Protocol\nreactiveclass Node(10) {\n\tknownrebecs {\n\t    Node node1;\n\t    Node node2;\n\t}\n\tstatevars {\n\t    byte srvNo;\n\t\tboolean recievedResults;\n\t\tboolean creationAbility;\n\t\tint recievedResultsCounter;\n\t\tint expectedResultsCounter;\n\t\tboolean[2] cooperatorKnownRebecs;\n\t\t\n\t}\n\t\n\tmsgsrv initial(boolean nodeCreationAbility) {\n\t\tcreationAbility = nodeCreationAbility;\n\t\tself.createTransaction();\n\t}\n\t\n\tmsgsrv createTransaction() {\n\n\t\tboolean startTrans;\n\t\tstartTrans = ?(true, false);\n\t\tif (startTrans && creationAbility) {\n\t\t\tboolean dispatcher = false;\n\t\t\tboolean result;\n\n\t\t\tint i;\n\t\t\tfor(i = 0; i < 2; i = i + 1)\n\t\t\t\tcooperatorKnownRebecs[i] = false;\n\n\t\t\trecievedResultsCounter = 0;\n\t\t\trecievedResults = true;\n\n\n\t\t\texpectedResultsCounter = 0;\n\n            srvNo = 1;\n\t\t\tdispatcher = ?(true, false);\n\t\t\tif (dispatcher) {\n\t\t\t\tcooperatorKnownRebecs[0] = true;\n\t\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\t\tnode1.startGlobalTransaction();\n\t\t\t}\n\n\t\t\tdispatcher = ?(true, false);\n\t\t\tif (dispatcher) {\n\t\t\t\tcooperatorKnownRebecs[1] = true;\n\t\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\t\tnode2.startGlobalTransaction();\n\t\t\t}\n\n\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\tresult = ?(true, false);\n\t\t\tself.cooperatorResponse(result);\n\t\t}\n\t\telse {\n\t\t\tself.createTransaction();\n\t\t}\n\t}\n\t\n\tmsgsrv startGlobalTransaction() {\n\t\tboolean result;\n\t\tresult = ?(true, false);\n\n\t\tif (sender == node1) {\n\t\t\tnode1.cooperatorResponse(result);\n\t\t}\n\t\tif (sender == node2) {\n\t\t\tnode2.cooperatorResponse(result);\n        }\n        \n\t}\n\n\tmsgsrv cooperatorResponse(boolean result) {\n\t\trecievedResultsCounter = recievedResultsCounter + 1;\n\t\tif (!result)\n\t\t\trecievedResults = false;\n\n\t\tif (recievedResultsCounter == expectedResultsCounter) {\n            int i;\n\t\t\tif (cooperatorKnownRebecs[0]) {\n\t\t\t\tnode1.applyResult(recievedResults);\n\t\t\t}\n\t\t\tif (cooperatorKnownRebecs[1]) {\n\t\t\t\tnode2.applyResult(recievedResults);\n\t\t\t}\n\n\t\t\tself.createTransaction();\n\t\t}\n\t}\n\t\n\n\tmsgsrv applyResult(boolean result) {\n\t}\n\n}\n\n\nmain {\n\tNode node1(node2, node3):(true);\n\tNode node2(node3, node1):(false);\n\tNode node3(node1, node2):(true);\n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "2-phase commit (fixed)" -> "// Adapted version without arrays\n//2 Phase Commit Protocol\nreactiveclass Node(10) {\n\tknownrebecs {\n\t    Node node1;\n\t    Node node2;\n\t}\n\tstatevars {\n\t    byte srvNo;\n\t\tboolean recievedResults;\n\t\tboolean creationAbility;\n\t\tint recievedResultsCounter;\n\t\tint expectedResultsCounter;\n\t\tboolean cooperatorKnownRebecs0;\n\t\tboolean cooperatorKnownRebecs1;\n\t\t\n\t}\n\t\n\tmsgsrv initial(boolean nodeCreationAbility) {\n\t\tcreationAbility = nodeCreationAbility;\n\t\tself.createTransaction();\n\t}\n\t\n\tmsgsrv createTransaction() {\n\n\t\t//boolean startTrans;\n\t\tstartTrans = ?(true, false);\n\t\tif (startTrans && creationAbility) {\n\t\t\t//boolean dispatcher = false;\n\t\t\t//boolean result;\n\n\t\t\t//int i;\n\t\t\t//for(i = 0; i < 2; i = i + 1)\n\t\t\t//\tcooperatorKnownRebecs[i] = false;\n      cooperatorKnownRebecs0 = false;\n      cooperatorKnownRebecs1 = false;\n\n\t\t\trecievedResultsCounter = 0;\n\t\t\trecievedResults = true;\n\n\n\t\t\texpectedResultsCounter = 0;\n\n            srvNo = 1;\n\t\t\tdispatcher = ?(true, false);\n\t\t\tif (dispatcher) {\n\t\t\t\tcooperatorKnownRebecs0 = true;\n\t\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\t\tnode1.startGlobalTransaction();\n\t\t\t}\n\n\t\t\tdispatcher = ?(true, false);\n\t\t\tif (dispatcher) {\n\t\t\t\tcooperatorKnownRebecs1 = true;\n\t\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\t\tnode2.startGlobalTransaction();\n\t\t\t}\n\n\t\t\texpectedResultsCounter = expectedResultsCounter + 1;\n\t\t\tresult = ?(true, false);\n\t\t\tself.cooperatorResponse(result);\n\t\t}\n\t\telse {\n\t\t\tself.createTransaction();\n\t\t}\n\t}\n\t\n\tmsgsrv startGlobalTransaction() {\n\t\t//boolean result;\n\t\tresult = ?(true, false);\n\n\t\tif (sender == node1) {\n\t\t\tnode1.cooperatorResponse(result);\n\t\t}\n\t\tif (sender == node2) {\n\t\t\tnode2.cooperatorResponse(result);\n        }\n        \n\t}\n\n\tmsgsrv cooperatorResponse(boolean result) {\n\t\trecievedResultsCounter = recievedResultsCounter + 1;\n\t\tif (!result)\n\t\t\trecievedResults = false;\n\n\t\tif (recievedResultsCounter == expectedResultsCounter) {\n            //int i;\n\t\t\tif (cooperatorKnownRebecs0) {\n\t\t\t\tnode1.applyResult(recievedResults);\n\t\t\t}\n\t\t\tif (cooperatorKnownRebecs1) {\n\t\t\t\tnode2.applyResult(recievedResults);\n\t\t\t}\n\n\t\t\tself.createTransaction();\n\t\t}\n\t}\n\t\n\n\tmsgsrv applyResult(boolean result) {\n\t}\n\n}\n\n\nmain {\n\tNode node1(node2, node3):(true);\n\tNode node2(node3, node1):(false);\n\tNode node3(node1, node2):(true);\n}"
      -> "Adapted, without arrays, from <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Sender-receiver" -> "reactiveclass Sender(5) { \n\tknownrebecs { \n\t\tMedium medium; \n\t\tReceiver rec;     \n\t} \n      \n\tstatevars { \n\t\tboolean receivedBit; \n\t\tboolean sendBit; \n\t\tboolean hasSucceeded; \n\t} \n  \n\tmsgsrv initial() { \n\t\tsendBit = false; \n\t\tmedium.pass(sendBit); \n\t\tself.sendMsg(); \n    hasSucceeded = false;\n\t} \n  \n\tmsgsrv sendMsg() { \n\t\t//receive(hasSucceeded) \n\t\tif (hasSucceeded == true) { \n\t\t\tif (sendBit == true) { \n\t\t\t\tsendBit = false; \n\t\t\t} else { \n\t\t\t\tsendBit = true; \n\t\t\t} \n\t\t} \n            \n\t\tmedium.pass(sendBit); \n\t\tself.sendMsg(); \n\t} \n} \n  \nreactiveclass Receiver(5) { \n\tknownrebecs { \n\t\tMedium medium; \n\t\tSender sender;    \n\t} \n      \n\tstatevars { \n\t\tboolean messageBit; \n\t} \n  \n\tmsgsrv initial() { \n\t} \n  \n\tmsgsrv receiveMsg(boolean msgBit) { \n\t\tmessageBit =msgBit; \n\t\t//sender.receive(true); \n\t} \n} \n  \nreactiveclass Medium(5) { \n\tknownrebecs { \n\t\tReceiver receiver; \n\t\tSender sender;    \n\t} \n      \n\tstatevars { \n\t\tboolean passMessage; \n\t} \n  \n\tmsgsrv initial() { \n\t\tpassMessage=true; \n\t} \n  \n\tmsgsrv pass(boolean msgBit) { \n\t\tpassMessage = ?(true,false); \n\t\tif(passMessage == true) { \n\t\t\treceiver.receiveMsg( msgBit); \n\t\t} else { \n\t\t\t//sender,receive(false); \n\t\t} \n\t} \n} \n  \nmain { \n\tSender sender (medium, receiver):(); \n\tMedium medium(receiver, sender):(); \n\tReceiver receiver(medium, sender):(); \n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Prod-Cons (larger)" -> "reactiveclass BufferManager(4) {\n\tknownrebecs {\n\t\tProducer producer;\n\t\tConsumer consumer;\n\t}\n\n\tstatevars {\n\t\tboolean empty;\n\t\tboolean full;\n\t\tboolean producerWaiting;\n\t\tboolean consumerWaiting;\n\t\tint bufferlenght;\n\t\tint nextProduce;\n\t\tint nextConsume;\t\t\n\t}\n\n\tmsgsrv initial() {\n\t\tbufferlenght = 2;\n\t\tempty = true;\n\t\tfull = false;\n\t\tproducerWaiting = false;\n\t\tconsumerWaiting = false;\n\t\tnextProduce = 0;\n\t\tnextConsume = 0;\n\t}\n\n\tmsgsrv giveMeNextProduce() {\n\t\tif (!full)\t{\n\t\t\tproducer.produce(nextProduce);\n\t\t} \n\t}\n\n\tmsgsrv giveMeNextConsume() {\n\t\tif (!empty) {\n\t\t\tconsumer.consume(nextConsume);\n\t\t} \n     \telse {\n\t\t\tconsumerWaiting = true;\n\t\t}\n\t}\n\n\tmsgsrv ackProduce() {\n\t\tnextProduce = (nextProduce + 1) %\n                    bufferlenght;\n\t\tif (nextProduce == nextConsume) {\n\t\t\tfull = true;\n\t\t}\n\t\tempty = false;\n\t\tif (consumerWaiting) {\n\t\t\tconsumer.consume(nextConsume);\n\t\t\tconsumerWaiting = false;\n\t\t}\n\t}\n\n\tmsgsrv ackConsume() {\n\t\tnextConsume = (nextConsume + 1) %\n                    bufferlenght;\n\t\tif (nextConsume == nextProduce) {\n\t\t\tempty = true;\n\t\t}\n\t\tfull = false;\n\t\tif (producerWaiting) {\n\t\t\tproducer.produce(nextProduce);\n\t\t\tproducerWaiting = false;\n\t\t}\n\t}\n}\n\nreactiveclass Producer(2) {\n\tknownrebecs {\n\t\tBufferManager buffer;\n\t}\n\n\tstatevars {\n\t}\n\n\tmsgsrv initial() {\n\t\tself.beginProduce();\n\t}\n\t\n\tmsgsrv produce(int bufNum) {\n\t\tbuffer.ackProduce();\n\t\tself.beginProduce();\n\t}\n\n\tmsgsrv beginProduce() {\n\t\tbuffer.giveMeNextProduce();\n\t}\n}\n\nreactiveclass Consumer(2) {\n\tknownrebecs {\n\t\tBufferManager buffer;\t\t\n\t}\n\n\tstatevars {\n\t}\n\n\tmsgsrv initial() {\n\t\tself.beginConsume();\n\t}\n\n\tmsgsrv consume(int bufNum) {\n\t\tbuffer.ackConsume();\n\t\tself.beginConsume();\t\n\t}\n\t\n\tmsgsrv beginConsume() {\n\t\tbuffer.giveMeNextConsume();\n\t}\n\n}\n\nmain { \n\tBufferManager buffer(producer, consumer):();\n\tProducer producer(buffer):();\n\tConsumer consumer(buffer):();\n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Spanning-tree" -> "reactiveclass RootController(7)\n{\n       knownrebecs\n       {\n               PortController pController1;\n               PortController pController2;\n               PortController pController3;\n//               PortController pController4;\n//               PortController pController5;\n       }\n       statevars\n       {\n               byte rootID;\n               byte rootDistance;\n               byte myID;\n               boolean IamRoot;\n       }\n\n       msgsrv initial(byte id)\n       {\n               myID = id;\n               rootID = myID;\n               rootDistance = 0;\n               IamRoot = true;\n               self.config();\n       }\n\n       msgsrv recvInf( byte senderID, byte distance, byte believedRootID)\n       {\n               if( believedRootID < rootID)\n               {\n                       rootID = believedRootID;\n                       rootDistance = (byte)(distance + 1);\n                       IamRoot = false;\n\n                       //sender.setBestPort();                                               *\n                       //if( sender != pController1)                                         *\n                       if(true)\n                       {\n                               pController1.setBadPort();\n                       }\n                       //if( sender != pController2)                                         *\n                       if(true)\n                       {\n                               pController2.setBadPort();\n                       }\n                       //if( sender != pController3)                                         *\n                       if(true)\n                       {\n                               pController3.setBadPort();\n                       }\n                       //if( sender != pController4)                                         *\n                       //if(true)\n                       //{\n                       //        pController4.setBadPort();\n                       //}\n                       //if( sender != pController5)                                         *\n                       //if(true)\n                       //{\n                       //        pController5.setBadPort();\n                       //}\n\n                       //receive(best);                                                      *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n\n                       pController1.sendLan( myID, rootDistance, rootID);\n                       pController2.sendLan( myID, rootDistance, rootID);\n                       pController3.sendLan( myID, rootDistance, rootID);\n                       //pController4.sendLan( myID, rootDistance, rootID);\n                       //pController5.sendLan( myID, rootDistance, rootID);\n               }\n               else\n               {\n                       if( believedRootID == rootID && distance + 1  < rootDistance)\n                       {\n                               rootID = believedRootID;\n                               rootDistance = (byte)(distance + 1);\n                               //sender.setBestPort();                                  *\n                               //if( sender != pController1)                            *\n                               if(true)\n                               {\n                                       pController1.setBadPort();\n                               }\n                               //if( sender != pController2)                            *\n                               if(true)\n                               {\n                                       pController2.setBadPort();\n                               }\n                               //if( sender != pController3)                            *\n                               if(true)\n                               {\n                                       pController3.setBadPort();\n                               }\n                               //if( sender != pController4)                            *\n                               //if(true)\n                               //{\n                               //        pController4.setBadPort();\n                               //}\n                               //if( sender != pController5)                            *\n                               //if(true)\n                               //{\n                               //        pController5.setBadPort();\n                               //}\n\n                               //receive( best);                                        *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n\n\n                               pController1.sendLan( myID, rootDistance, rootID);\n                               pController2.sendLan( myID, rootDistance, rootID);\n                               pController3.sendLan( myID, rootDistance, rootID);\n                               //pController4.sendLan( myID, rootDistance, rootID);\n                               //pController5.sendLan( myID, rootDistance, rootID);\n                       }\n                       else\n                       {\n                            if(believedRootID == rootID && distance + 1 == rootDistance)\n                            {}\n                            else\n                            {\n                                self.config();\n                            }\n                       }\n               }\n\n       }\n       msgsrv config()\n       {\n               if( IamRoot)\n               {\n                       pController1.sendLan( myID, 0, myID);\n                       pController2.sendLan( myID, 0, myID);\n                       pController3.sendLan( myID, 0, myID);\n                       //pController4.sendLan( myID, 0, myID);\n                       //pController5.sendLan( myID, 0, myID);\n               }\n\n       }\n}\nreactiveclass PortController(4)\n{\n     knownrebecs\n     {\n             RootController  rootController;\n             BridgeToLanPort bridgeToLan;\n             LanToBridgePort lanToBridge;\n     }\n\n     statevars\n     {\n             byte rootID;\n             byte rootDistance;\n             boolean isTheBestPort;\n     }\n\n     msgsrv initial()\n     {\n             rootID = (byte)255;\n             rootDistance = (byte)255;\n     }\n\n     msgsrv setBestPort()\n     {\n             isTheBestPort = true;\n             //rootController.best();                                           *\n     }\n\n     msgsrv setBadPort()\n     {\n             isTheBestPort = false;\n             //rootController.bad();                                            *\n     }\n\n     msgsrv sendLan( byte senderID, byte distance, byte believedRootID)\n     {\n             if( believedRootID < rootID)\n             {\n                     bridgeToLan.turnOn();\n                     //receive( alive);                                         *\n                     bridgeToLan.send( senderID, distance, believedRootID);\n                     //receive( sendToLan );                                    *\n             }\n             else\n             {\n                     if( believedRootID == rootID && distance < rootDistance )\n                     {\n                             bridgeToLan.turnOn();\n                             //receive( alive);                                             *\n                             bridgeToLan.send( senderID, distance, believedRootID);\n                             //receive( sendToLan );                                        *\n                     }\n                     else\n                     {\n                             if( ! isTheBestPort)\n                             {\n                                     bridgeToLan.turnOff();\n                                     //receive( died);                                      *\n                             }\n                     }\n             }\n     }\n     msgsrv sendBridge( byte senderID, byte distance, byte believedRootID)\n     {\n             if( believedRootID < rootID)\n             {\n                  rootID = believedRootID;\n                  rootDistance = (byte)(distance + 1);\n             }\n             else\n             {\n                if( believedRootID == rootID && distance < rootDistance )\n                {\n                    rootDistance = (byte)(distance + 1);\n                }\n             }\n             rootController.recvInf( senderID, distance, believedRootID);\n             //lanToBridge.sendToBridge();                                                  *\n     }\n}\nreactiveclass BridgeToLanPort(3)\n{\n     knownrebecs\n     {\n             PortController portController;\n             ExtendedLan lan;\n     }\n\n     statevars\n     {\n             boolean alive;\n             byte myID;\n     }\n\n     msgsrv initial(byte id)\n     {\n             alive = true;\n             myID = id;\n     }\n     msgsrv turnOn()\n     {\n             alive = true;\n             //portController.alive();                                      *\n     }\n\n     msgsrv turnOff()\n     {\n             alive = false;\n             //portController.died();                                       *\n     }\n\n     msgsrv send( byte senderID, byte distance, byte believedRootID)\n     {\n             if(alive)\n             {\n                     lan.recv(myID, senderID, distance, believedRootID);\n             }\n             //portController.sendToLan();                                  *\n     }\n}\nreactiveclass LanToBridgePort(3)\n{\n     knownrebecs\n     {\n             PortController portController;\n     }\n     statevars\n     {byte myID;}\n\n     msgsrv initial(byte id)\n     {\n        myID = id;\n     }\n\n     msgsrv broadCast( byte portID , byte senderID, byte distance, byte believedRootID)\n     {\n             if(portID != myID)\n             {\n                portController.sendBridge( senderID, distance, believedRootID);\n                //recieve(sendToBridge)                                                            *\n             }\n\n     }\n}\nreactiveclass ExtendedLan(3)\n{\n     knownrebecs\n     {\n             LanToBridgePort port1;\n             LanToBridgePort port2;\n     }\n\n     statevars\n     {}\n\n     msgsrv initial()\n     {}\n\n     msgsrv recv(byte portID, byte senderID, byte distance, byte believedRootID)\n     {\n             //broadCast( portID, senderID, distance, believedRootID);\n     }\n}\n\n\nmain ////////////////////known objects binding\n{\n    RootController r1(p1D ,p1F ,p1D):(1);\n    RootController r5(p5D ,p5B ,p5D):(5);\n    RootController r7(p7F ,p7B ,p7K):(7);\n    PortController p1D(r1 ,out1D ,in1D):();\n    PortController p1F(r1 ,out1F ,in1F):();\n    PortController p5D(r5 ,out5D ,in5D):();\n    PortController p5B(r5 ,out5B ,in5B):();\n    PortController p7F(r7 ,out7F ,in7F):();\n    PortController p7B(r7 ,out7B ,in7B):();\n    PortController p7K(r7 ,out7K ,in7K):();\n\n    LanToBridgePort in1D(p1D):(1);\n    LanToBridgePort in1F(p1F):(2);\n    LanToBridgePort in5D(p5D):(3);\n    LanToBridgePort in5B(p5B):(4);\n    LanToBridgePort in7F(p7F):(5);\n    LanToBridgePort in7B(p7B):(6);\n    LanToBridgePort in7K(p7K):(7);\n\n    BridgeToLanPort out1D(p1D,D):(1);\n    BridgeToLanPort out1F(p1F,F):(2);\n    BridgeToLanPort out5D(p5D,D):(3);\n    BridgeToLanPort out5B(p5B,B):(4);\n    BridgeToLanPort out7F(p7F,F):(5);\n    BridgeToLanPort out7B(p7B,B):(6);\n    BridgeToLanPort out7K(p7K,K):(7);\n\n    ExtendedLan D(in1D, in5D):();\n    ExtendedLan B(in7B, in5B):();\n    ExtendedLan F(in1F, in7F):();\n    ExtendedLan K(in7K, in7K):();\n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Spanning-tree (fixed)" -> "reactiveclass RootController(7)\n{\n       knownrebecs\n       {\n               PortController pController1;\n               PortController pController2;\n               PortController pController3;\n//               PortController pController4;\n//               PortController pController5;\n       }\n       statevars\n       {\n               byte rootID;\n               byte rootDistance;\n               byte myID;\n               boolean IamRoot;\n       }\n\n       msgsrv initial(byte id)\n       {\n               myID = id;\n               rootID = myID;\n               rootDistance = 0;\n               IamRoot = true;\n               self.config();\n       }\n\n       msgsrv recvInf( byte senderID, byte distance, byte believedRootID)\n       {\n               if( believedRootID < rootID)\n               {\n                       rootID = believedRootID;\n                       rootDistance = (distance + 1);\n                       IamRoot = false;\n\n                       //sender.setBestPort();                                               *\n                       //if( sender != pController1)                                         *\n                       if(true)\n                       {\n                               pController1.setBadPort();\n                       }\n                       //if( sender != pController2)                                         *\n                       if(true)\n                       {\n                               pController2.setBadPort();\n                       }\n                       //if( sender != pController3)                                         *\n                       if(true)\n                       {\n                               pController3.setBadPort();\n                       }\n                       //if( sender != pController4)                                         *\n                       //if(true)\n                       //{\n                       //        pController4.setBadPort();\n                       //}\n                       //if( sender != pController5)                                         *\n                       //if(true)\n                       //{\n                       //        pController5.setBadPort();\n                       //}\n\n                       //receive(best);                                                      *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n                       //receive(bad);                                                       *\n\n                       pController1.sendLan( myID, rootDistance, rootID);\n                       pController2.sendLan( myID, rootDistance, rootID);\n                       pController3.sendLan( myID, rootDistance, rootID);\n                       //pController4.sendLan( myID, rootDistance, rootID);\n                       //pController5.sendLan( myID, rootDistance, rootID);\n               }\n               else\n               {\n                       if( believedRootID == rootID && distance + 1  < rootDistance)\n                       {\n                               rootID = believedRootID;\n                               rootDistance = (distance + 1);\n                               //sender.setBestPort();                                  *\n                               //if( sender != pController1)                            *\n                               if(true)\n                               {\n                                       pController1.setBadPort();\n                               }\n                               //if( sender != pController2)                            *\n                               if(true)\n                               {\n                                       pController2.setBadPort();\n                               }\n                               //if( sender != pController3)                            *\n                               if(true)\n                               {\n                                       pController3.setBadPort();\n                               }\n                               //if( sender != pController4)                            *\n                               //if(true)\n                               //{\n                               //        pController4.setBadPort();\n                               //}\n                               //if( sender != pController5)                            *\n                               //if(true)\n                               //{\n                               //        pController5.setBadPort();\n                               //}\n\n                               //receive( best);                                        *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n                               //receive( bad);                                         *\n\n\n                               pController1.sendLan( myID, rootDistance, rootID);\n                               pController2.sendLan( myID, rootDistance, rootID);\n                               pController3.sendLan( myID, rootDistance, rootID);\n                               //pController4.sendLan( myID, rootDistance, rootID);\n                               //pController5.sendLan( myID, rootDistance, rootID);\n                       }\n                       else\n                       {\n                            if(believedRootID == rootID && distance + 1 == rootDistance)\n                            {}\n                            else\n                            {\n                                self.config();\n                            }\n                       }\n               }\n\n       }\n       msgsrv config()\n       {\n               if( IamRoot)\n               {\n                       pController1.sendLan( myID, 0, myID);\n                       pController2.sendLan( myID, 0, myID);\n                       pController3.sendLan( myID, 0, myID);\n                       //pController4.sendLan( myID, 0, myID);\n                       //pController5.sendLan( myID, 0, myID);\n               }\n\n       }\n}\nreactiveclass PortController(4)\n{\n     knownrebecs\n     {\n             RootController  rootController;\n             BridgeToLanPort bridgeToLan;\n             LanToBridgePort lanToBridge;\n     }\n\n     statevars\n     {\n             byte rootID;\n             byte rootDistance;\n             boolean isTheBestPort;\n     }\n\n     msgsrv initial()\n     {\n             rootID = 255;\n             rootDistance = 255;\n     }\n\n     msgsrv setBestPort()\n     {\n             isTheBestPort = true;\n             //rootController.best();                                           *\n     }\n\n     msgsrv setBadPort()\n     {\n             isTheBestPort = false;\n             //rootController.bad();                                            *\n     }\n\n     msgsrv sendLan( byte senderID, byte distance, byte believedRootID)\n     {\n             if( believedRootID < rootID)\n             {\n                     bridgeToLan.turnOn();\n                     //receive( alive);                                         *\n                     bridgeToLan.send( senderID, distance, believedRootID);\n                     //receive( sendToLan );                                    *\n             }\n             else\n             {\n                     if( believedRootID == rootID && distance < rootDistance )\n                     {\n                             bridgeToLan.turnOn();\n                             //receive( alive);                                             *\n                             bridgeToLan.send( senderID, distance, believedRootID);\n                             //receive( sendToLan );                                        *\n                     }\n                     else\n                     {\n                             if( !isTheBestPort)\n                             {\n                                     bridgeToLan.turnOff();\n                                     //receive( died);                                      *\n                             }\n                     }\n             }\n     }\n     msgsrv sendBridge( byte senderID, byte distance, byte believedRootID)\n     {\n             if( believedRootID < rootID)\n             {\n                  rootID = believedRootID;\n                  rootDistance = (distance + 1);\n             }\n             else\n             {\n                if( believedRootID == rootID && distance < rootDistance )\n                {\n                    rootDistance = (distance + 1);\n                }\n             }\n             rootController.recvInf( senderID, distance, believedRootID);\n             //lanToBridge.sendToBridge();                                                  *\n     }\n}\nreactiveclass BridgeToLanPort(3)\n{\n     knownrebecs\n     {\n             PortController portController;\n             ExtendedLan lan;\n     }\n\n     statevars\n     {\n             boolean alive;\n             byte myID;\n     }\n\n     msgsrv initial(byte id)\n     {\n             alive = true;\n             myID = id;\n     }\n     msgsrv turnOn()\n     {\n             alive = true;\n             //portController.alive();                                      *\n     }\n\n     msgsrv turnOff()\n     {\n             alive = false;\n             //portController.died();                                       *\n     }\n\n     msgsrv send( byte senderID, byte distance, byte believedRootID)\n     {\n             if(alive)\n             {\n                     lan.recv(myID, senderID, distance, believedRootID);\n             }\n             //portController.sendToLan();                                  *\n     }\n}\nreactiveclass LanToBridgePort(3)\n{\n     knownrebecs\n     {\n             PortController portController;\n     }\n     statevars\n     {byte myID;}\n\n     msgsrv initial(byte id)\n     {\n        myID = id;\n     }\n\n     msgsrv broadCast( byte portID , byte senderID, byte distance, byte believedRootID)\n     {\n             if(portID != myID)\n             {\n                portController.sendBridge( senderID, distance, believedRootID);\n                //recieve(sendToBridge)                                                            *\n             }\n\n     }\n}\nreactiveclass ExtendedLan(3)\n{\n     knownrebecs\n     {\n             LanToBridgePort port1;\n             LanToBridgePort port2;\n     }\n\n     statevars\n     {}\n\n     msgsrv initial()\n     {}\n\n     msgsrv recv(byte portID, byte senderID, byte distance, byte believedRootID)\n     {\n             //broadCast( portID, senderID, distance, believedRootID);\n     }\n}\n\n\nmain ////////////////////known objects binding\n{\n    RootController r1(p1D ,p1F ,p1D):(1);\n    RootController r5(p5D ,p5B ,p5D):(5);\n    RootController r7(p7F ,p7B ,p7K):(7);\n    PortController p1D(r1 ,out1D ,in1D):();\n    PortController p1F(r1 ,out1F ,in1F):();\n    PortController p5D(r5 ,out5D ,in5D):();\n    PortController p5B(r5 ,out5B ,in5B):();\n    PortController p7F(r7 ,out7F ,in7F):();\n    PortController p7B(r7 ,out7B ,in7B):();\n    PortController p7K(r7 ,out7K ,in7K):();\n\n    LanToBridgePort in1D(p1D):(1);\n    LanToBridgePort in1F(p1F):(2);\n    LanToBridgePort in5D(p5D):(3);\n    LanToBridgePort in5B(p5B):(4);\n    LanToBridgePort in7F(p7F):(5);\n    LanToBridgePort in7B(p7B):(6);\n    LanToBridgePort in7K(p7K):(7);\n\n    BridgeToLanPort out1D(p1D,d):(1);\n    BridgeToLanPort out1F(p1F,f):(2);\n    BridgeToLanPort out5D(p5D,d):(3);\n    BridgeToLanPort out5B(p5B,b):(4);\n    BridgeToLanPort out7F(p7F,f):(5);\n    BridgeToLanPort out7B(p7B,b):(6);\n    BridgeToLanPort out7K(p7K,k):(7);\n\n    ExtendedLan d(in1D, in5D):();\n    ExtendedLan b(in7B, in5B):();\n    ExtendedLan f(in1F, in7F):();\n    ExtendedLan k(in7K, in7K):();\n}"
      -> "Adapted from <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "NOC" -> "/*\n\n* Model for 4x4 ASPIN. The model can be extended for lager NoCs by declaring routers in main part (last section of the code).\n\n*In the model only one packet is sent from router R00 to router R23. More packets can be scheduled to sent from a source to destination \n as like in \"Router\" mesage server.\n\n*/\n\nreactiveclass Manager(10){\n\t\n\tknownrebecs{\n\t\tRouter r00;\n\t\tRouter r10;\n\t\tRouter r20;\n\t\tRouter r30;\n\t\t\n\t\tRouter r01;\n\t\tRouter r11;\n\t\tRouter r21;\n\t\tRouter r31;\n\t\t\n\t\tRouter r02;\n\t\tRouter r12;\n\t\tRouter r22;\n\t\tRouter r32;\n\t\t\n\t\tRouter r03;\n\t\tRouter r13;\n\t\tRouter r23;\n\t\tRouter r33;\n\t}\n\t\n\tstatevars{\n\t}\n\t\n\tManager(){\n\t}\n\t\n\tmsgsrv reset(){ //each source and destination routeeer should be initialized here.\n\t\tr01.reStart() after(700); //source\t\t\n\t}\n}\n\nreactiveclass Router(10) {\n\n\tknownrebecs {\n\t\tManager manager;\n\t\tRouter N;  // : 0\n\t\tRouter E;  // : 1\n\t\tRouter S;  // : 2\n\t\tRouter W;  // : 3\t\t\n\t}\n\t\n\tstatevars {\n\t\tint bufSize;\n\t\tint maxTime;\t// To check if a packet is recieved by the time maxTime\n\t\tint recieved;\n\t\t\n\t\tbyte[4] bufNum; //for each of four sides\n\t\tboolean[4] full;\n\t\tboolean[4] enable;\n\t\tboolean [4] outMutex;\n\t\t\n\t\tbyte Xid;\n\t\tbyte Yid;\n\t}\n\t\n\tRouter(byte X, byte Y){\t\n\t\tXid = X;\n\t\tYid = Y;\n\t\n\t\tbufSize = 2;\n\t\tmaxTime = 250 ; \n\t\trecieved = 0;\n\n\t\tfor(int i=0;i<4;i++){\t\t\n\t\t\tenable[i] = true;\n\t\t\toutMutex[i] = true;\n\t\t\tbufNum[i] = 0;\n\t\t\tfull[i] = false;\n\t\t}\n\t\t\n\t\t//packet generation\n\t\tif(X == 0 && Y == 0){\n\t\t\tself.reqSend(2,3,1,5) after(10);  //sending a packet\n\t\t}\n\t\t\n\t\tif(X == 0 && Y == 1){\t\t\t\t// permamnet, don't change. \n\t\t\tself.reStart() after(700);\n\t\t}\n\t\t\n\t\tif(X == 2 && Y == 3){\t\t\t\t// in destination router. not necessary for all packets. just to check when the packet is recieved\n\t\t\tself.checkRecieved()after(maxTime);\n\t\t}\n\t}\n\t\n\tmsgsrv reqSend(byte Xtarget, byte Ytarget, int directionS, int packId){\t\n\t\tif (enable[directionS] == true){\n\t\t\tboolean sent = false;\n\t\t\t\t\t\n\t\t\tif(Xtarget > Xid){\t\t// Routing Algorithm XY: first move through horisental channels \n\t\t\t\tif(outMutex[1] == true){\t\n\t\t\t\t\tE.give_Ack(Xtarget, Ytarget,directionS,3,5, packId) after(26);\n\t\t\t\t\toutMutex[1] = false;\n\t\t\t\t\tenable[directionS] = false;\n\t\t\t\t\tsent = true;\n\t\t\t\t}else\n\t\t\t\t\tself.reqSend(Xtarget, Ytarget,directionS, packId) after(1);\n\t\t\t}\t\n\t\t\telse if(Xtarget < Xid){\t\n\t\t\t\tif(outMutex[3] == true){\n\t\t\t\t\tW.give_Ack(Xtarget, Ytarget,directionS,1,5, packId ) after(26);\t\n\t\t\t\t\toutMutex[3] = false;\n\t\t\t\t\tenable[directionS] = false;\n\t\t\t\t\tsent = true;\n\t\t\t\t} else\n\t\t\t\t\tself.reqSend(Xtarget, Ytarget,directionS, packId) after(1);\n\t\t\t}\t\n\t\t\telse if(Ytarget > Yid){\t\n\t\t\t\tif(outMutex[2] == true){\n\t\t\t\t\tS.give_Ack(Xtarget, Ytarget,directionS,0,5, packId ) after(26);\t\n\t\t\t\t\toutMutex [2] = false;\n\t\t\t\t\tenable[directionS] = false;\n\t\t\t\t\tsent = true;\n\t\t\t\t}else\n\t\t\t\t\tself.reqSend(Xtarget, Ytarget,directionS, packId) after(1);\t\n\t\t\t}\t\n\t\t\telse if(Ytarget < Yid){\t\n\t\t\t\tif(outMutex[0] == true){\n\t\t\t\t\tN.give_Ack(Xtarget, Ytarget,directionS,2,5 , packId) after(26);\t\n\t\t\t\t\toutMutex[0] = false;\n\t\t\t\t\tenable[directionS] = false;\n\t\t\t\t\tsent = true;\n\t\t\t\t}else\n\t\t\t\t\tself.reqSend(Xtarget, Ytarget,directionS,packId) after(1);\n\t\t\t}\n\n\t\t\tif(sent == true){\n\t\t\t\tbufNum[directionS] = (byte)bufNum[directionS] + 1;\n\n\t\t\t\tif (bufNum[directionS] == bufSize) full[directionS] = true;         //update the value of \"full\".\n\t\t\t}\t\n\t\t} else\n\t\t\tself.reqSend(Xtarget, Ytarget,directionS,packId) after(1);\n\t}\n\t\n\tmsgsrv get_Ack(int directionS){\n\t\t\n\t\tenable[directionS] = true;\n\t\t\n\t\tbufNum[directionS] = (byte)bufNum[directionS] - 1;\t\n\t\tfull[directionS] = false;\n\n\t\tif (sender == N) {\n\t\t\toutMutex[0] = true;\n\t\t}\t\n\t\telse if (sender == E){ \n\t\t\toutMutex[1] = true;\n\t\t}\t\n\t\telse if (sender == S){\n\t\t\toutMutex[2] = true;\n\t\t\t}\n\t\telse if (sender == W){ \n\t\t\toutMutex[3] = true;\n\t\t}\t\n\t}\n\t\n\tmsgsrv give_Ack(byte Xtarget, byte Ytarget,int directionS, int directionD,int msgSender, int packId){\n\t\tint MSGSender;\n\t\tif(sender == N)\n\t\t\tMSGSender = 0;\n\t\telse if (sender == E)\n\t\t\tMSGSender = 1;\n\t\telse if (sender == S)\n\t\t\tMSGSender = 2;\n\t\telse if (sender == W)\n\t\t\tMSGSender = 3;\n\t\telse {MSGSender = msgSender;\n\t\t\t\n\t\t}\n\t\t\t\t\n\t\tif(!(Xtarget == Xid && Ytarget == Yid)){\n\t\t\t\t\n\t\t\tif (full[directionD]) //buffer is full, the packet should wait.\n\t\t\t\tself.give_Ack(Xtarget, Ytarget,directionS,directionD,MSGSender,\n\t\t\t\t\t\t\t packId)after(2)deadline(3); //waiting via recalling give_ack after 2 time units.\n\t\t\t\n\t\t\telse{\t\n\t\t\t\tself.reqSend(Xtarget, Ytarget,directionD, packId); \n\t\t\t\t\t\n\t\t\t\tif(MSGSender == 0)\n\t\t\t\t\tN.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 1)\t\t\n\t\t\t\t\tE.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 2)\t\t\n\t\t\t\t\tS.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 3)\t\t\n\t\t\t\t\tW.get_Ack(directionS);\n\t\t\t}\t\t\n\t\t}\t\t\n\t\t\n\t\telse if((Xtarget == Xid && Ytarget == Yid)){ //reach target\n\t\t\t\t\n\t\t\t\trecieved = recieved + 1;\n\t\t\t\t\t\n\t\t\t\tif(MSGSender == 0)\n\t\t\t\t\tN.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 1)\t\t\n\t\t\t\t\tE.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 2)\t\t\n\t\t\t\t\tS.get_Ack(directionS);\n\t\t\t\telse if(MSGSender == 3)\t\t\n\t\t\t\t\tW.get_Ack(directionS);\n\t\t\t}\n\t}\n\n\tmsgsrv reStart(){\n\t\tmanager.reset();\n\t}\t\n\t\n\tmsgsrv deadlineMiss(){\n\t\tdelay(5);\n\t}\n\t\n\tmsgsrv checkPoint(){ // causes to hult\n\t\tself.deadlineMiss() after(1)deadline(3);\n\t\tself.deadlineMiss() after(1)deadline(3);\n\t}\n\t\n\tmsgsrv checkRecieved(){ // Halt if recieved is 0, by calling checkpoint.(checkpoint method allways cause program to hult).\n\t\t\n\t\tif (recieved == 0){\n\t\t\tself.checkPoint();\n\t\t}\n\t\t\t\n\t}\n}\n\nmain {\n\tManager m(r00,r10,r20,r30,r01,r11,r21,r31,r02,r12,r22,r32,r03,r13,r23,r33):();\n\t\n\tRouter r00(m,r03,r10,r01,r30):(0,0);\n\tRouter r10(m,r13,r20,r11,r00):(1,0);\n\tRouter r20(m,r23,r30,r21,r10):(2,0);\n\tRouter r30(m,r33,r00,r31,r20):(3,0);\n\t\n\tRouter r01(m,r00,r11,r02,r31):(0,1);\n\tRouter r11(m,r10,r21,r12,r01):(1,1);\n\tRouter r21(m,r20,r31,r22,r11):(2,1);\n\tRouter r31(m,r30,r01,r32,r21):(3,1);\n\t\n\tRouter r02(m,r01,r12,r03,r32):(0,2);\n\tRouter r12(m,r11,r22,r13,r02):(1,2);\n\tRouter r22(m,r21,r32,r23,r12):(2,2);\n\tRouter r32(m,r31,r02,r33,r22):(3,2);\n\t\n\tRouter r03(m,r02,r13,r00,r33):(0,3);\n\tRouter r13(m,r12,r23,r10,r03):(1,3);\n\tRouter r23(m,r22,r33,r20,r13):(2,3);\n\tRouter r33(m,r32,r03,r30,r23):(3,3);\n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
    "Vehicles" -> "env int RESENDING_PERIOD = 25;\nenv int NORMAL_SPEED = 15;\nenv int REDUCED_SPEED = 7;\nenv int SAFE_DISTANCE = 20;  // segments has 1000 meters length and each sub-segment has 200 meteres length\nenv int SEGMENT_LENGTH = 200;\nenv int LOADING_TIME_PC = 60;\nenv int LOADING_TIME_WL = 60;\nenv int UNLOADING_TIME_SC = 30;\nenv int CHARGING_TIME_C1 = 60;\nenv int CHARGING_TIME_C2 = 60;\nenv int LEAVING_PERIOD = 13;\nenv int NUMBER_VEHICLES = 4;\n\n//************* E1:WL, E2:Crusher, E3:SC, E4:DP ***********\n\nreactiveclass CrossController (10){\t\t// to control when S4 passes S3\n\tknownrebecs\n\t{\n\t}\n\tstatevars\n\t{\n\t\tboolean crossIsFree;\n\t}\n\tCrossController()\n\t{ \n\t\tcrossIsFree= true;\n\t}\n\tmsgsrv giveCrossPermission(int vehicleId){\n\t\tif(crossIsFree){\n\t\t\tcrossIsFree = false;\n\t\t\t((Segment)sender).getCrossPermission(vehicleId);\n\t\t}\n\t\telse ((Segment)sender).crossNotAvailable(vehicleId);\n\t}\n\tmsgsrv freeCross(int vehicleId){\n\t\tcrossIsFree = true;\t\n\t}\n}\n\nreactiveclass PrimaryCrusher (14) {\n\tknownrebecs\n\t{\n\t\tSegment firstSubSegPcToSc;\n\t}\n\tstatevars\n\t{\n\t\tboolean isLoading;\n\t}\n\tPrimaryCrusher()\n\t{ \n\t\tisLoading= false;\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId){\n\t \tif (isLoading == false){\n\t\t\tisLoading = true;\n\t\t\t((Segment)sender).getPermision(vehicleId);\n\t\t}\n\t\telse \n\t\t\t((Segment)sender).segmentNotFree(vehicleId);\n\t}\t\n\tmsgsrv vehicleEntered(int vehicleId){\n\t\tdelay(LOADING_TIME_PC);\n\t\tself.startSendingToNext(vehicleId);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tfirstSubSegPcToSc.givePermisionForVehicle(vehicleId,-1);\n\t}\n\tmsgsrv getPermision (int vehicleId){\n\t\tisLoading= false;\n\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree (int vehicleId){\n\t\tself.startSendingToNext(vehicleId) after(RESENDING_PERIOD);\n\t}\n}\n\nreactiveclass SecondaryCrusher (14) {\n\tknownrebecs\n\t{\n\t\tSegment firstSubSegScToPrepoint;\n\t}\n\tstatevars\n\t{\n\t\tboolean isUnloading;\n\t}\n\tSecondaryCrusher()\n\t{ \n\t\tisUnloading= false;\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId){\n\t \tif (isUnloading == false){\n\t\t\tisUnloading = true;\n\t\t\t((Segment)sender).getPermision(vehicleId);\n\t\t}\n\t\telse \n\t\t\t((Segment)sender).segmentNotFree(vehicleId);\n\t}\t\n\tmsgsrv vehicleEntered(int vehicleId){\n\t\tdelay(UNLOADING_TIME_SC);\n\t\tself.startSendingToNext(vehicleId);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tfirstSubSegScToPrepoint.givePermisionForVehicle(vehicleId,-1);\n\t}\n\tmsgsrv getPermision (int vehicleId){\n\t\tisUnloading= false;\n\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree (int vehicleId){\n\t\tself.startSendingToNext(vehicleId) after(RESENDING_PERIOD);\n\t}\n}\n\nreactiveclass PrePoint (14) { \t\t\t// the point at the end of S7\n\tknownrebecs\n\t{\n\t\tSegment firstSubSegPreToE1;\n\t\tSegment firstSubSegPreToE2;\n\t}\n\tstatevars\n\t{\n\t\tboolean isBusy;\n\t\tboolean toE1;\n\t\tint count;\n\t}\n\tPrePoint()\n\t{ \n\t\tisBusy= false;\n\t\ttoE1 = true;\n\t\tcount=0;\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId){\n\t \tif (isBusy == false){\n\t\t\tisBusy = true;\n\t\t\t((Segment)sender).getPermision(vehicleId);\n\t\t}\n\t\telse \n\t\t\t((Segment)sender).segmentNotFree(vehicleId);\n\t}\t\n\tmsgsrv vehicleEntered(int vehicleId){\n\t\tself.startSendingToNext(vehicleId);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tif(toE1)\n\t\t\tfirstSubSegPreToE1.givePermisionForVehicle(vehicleId,-1);\n\t}\n\tmsgsrv getPermision (int vehicleId){\n\t\tisBusy= false;\n\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree (int vehicleId){\n\t\tif(toE1){\n\t\t\ttoE1 = false;\n\t\t\tfirstSubSegPreToE2.givePermisionForVehicle(vehicleId, -1);\t\n\t\t}\n\t\telse \n\t\t{\n\t\t\ttoE1 = true;\n\t\t\tself.startSendingToNext(vehicleId) after(RESENDING_PERIOD);\n\t\t}\n\t}\n}\n\nreactiveclass DecisionStation (14) {\n\tknownrebecs\n\t{\n\t\tSegment firstSubSegDsToPc;\n\t}\n\tstatevars\n\t{\t\n\t\tboolean vehicle1Reached;\n\t\tboolean vehicle2Reached;\n\t\tboolean vehicle3Reached;\n\t\tboolean vehicle4Reached;\n\t\tboolean vehicle5Reached;\n\t\tboolean vehicle6Reached;\n\t\tboolean vehicle7Reached;\n\t\tboolean vehicle8Reached;\n\t}\n\tDecisionStation()\n\t{ \n\t\tself.leaveParkingSlots();\n\t}\n\tmsgsrv leaveParkingSlots(){\n\t\t\n\t\tstartSendingToNext(1) after(1);\n\t\t\n\t\tif(NUMBER_VEHICLES == 2 || NUMBER_VEHICLES == 3  || NUMBER_VEHICLES == 4 \n\t\t|| NUMBER_VEHICLES == 5 || NUMBER_VEHICLES == 6 || NUMBER_VEHICLES == 7 || NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(2) after(4);\n\t\t\t\n\t\tif(NUMBER_VEHICLES == 3  || NUMBER_VEHICLES == 4 || NUMBER_VEHICLES == 5 \n\t\t|| NUMBER_VEHICLES == 6 || NUMBER_VEHICLES == 7 || NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(3) after(6);\n\t\t\t\n\t\tif(NUMBER_VEHICLES == 4 || NUMBER_VEHICLES == 5 || NUMBER_VEHICLES == 6 \n\t\t|| NUMBER_VEHICLES == 7 || NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(4) after(9);\n\t\t\t\n \t\tif(NUMBER_VEHICLES == 5 || NUMBER_VEHICLES == 6 || NUMBER_VEHICLES == 7\n\t\t|| NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(5) after(12);\n\t\t\t\n\t\tif(NUMBER_VEHICLES == 6 || NUMBER_VEHICLES == 7 || NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(6) after(15);\n\t\t\t\n\t\tif(NUMBER_VEHICLES == 7 || NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(7) after(19);\n\t\t\n\t\tif(NUMBER_VEHICLES == 8)\n\t\t\tstartSendingToNext(8) after(26);\n\t}\n\tmsgsrv getPermision(int vehicleId){\n\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree(int vehicleId, int segmentDes){\n\t\tstartSendingToNext(vehicleId) after (RESENDING_PERIOD);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tfirstSubSegDsToPc.givePermisionForVehicle(vehicleId,1);\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId){\n\t\t((Segment)sender).getPermision(vehicleId);\n\t}\n\tmsgsrv vehicleEntered(int vehicleId){\n\t\t//startSendingToNext(vehicleId) after(LEAVING_PERIOD);\n\t\tif(vehicleId == 1)\n\t\t\tvehicle1Reached = true;\n\t\telse if(vehicleId == 2)\n\t\t\tvehicle2Reached = true;\n\t\telse if(vehicleId == 3)\n\t\t\tvehicle3Reached = true;\n\t\telse if(vehicleId == 4)\n\t\t\tvehicle4Reached = true;\n\t\telse if(vehicleId == 5)\n\t\t\tvehicle5Reached = true;\n\t\telse if(vehicleId == 6)\n\t\t\tvehicle6Reached = true;\n\t\telse if(vehicleId == 7)\n\t\t\tvehicle7Reached = true;\n\t\telse if(vehicleId == 8)\n\t\t\tvehicle8Reached = true;\n\t\t\n\t\t//if(NUMBER_VEHICLES == 4)\n\t\t//\t\tassertion(false);\n\t\t// when all vehicles travelled once the model checking stops by puting 'assertion(false)'\n\t\tif(NUMBER_VEHICLES == 1){\n\t\t\tif(vehicle1Reached == true)\n\t\t\t\tassertion(false);\n\t\t}\n\t\telse if(NUMBER_VEHICLES == 2){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true) \n\t\t\t\tassertion(false);\n\t\t}\n\t\telse if(NUMBER_VEHICLES == 3){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true) \n\t\t\t\tassertion(false);\n\t\t}\n\t\telse if(NUMBER_VEHICLES == 4){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true \n\t\t\t&& vehicle4Reached == true) \n\t\t\t\tassertion(false);\n\t\t}\t\t\n\t\telse if(NUMBER_VEHICLES == 5){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true \n\t\t\t&& vehicle4Reached == true && vehicle5Reached == true) \n\t\t\t\tassertion(false);\n\t\t}\t\t\n\t\telse if(NUMBER_VEHICLES == 6){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true \n\t\t\t&& vehicle4Reached == true && vehicle5Reached == true && vehicle6Reached == true)\n\t\t\t\tassertion(false);\n\t\t}\t\t\n\t\telse if(NUMBER_VEHICLES == 7){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true \n\t\t\t&& vehicle4Reached == true && vehicle5Reached == true && vehicle6Reached == true \n\t\t\t&& vehicle7Reached == true)\n\t\t\t\tassertion(false);\n\t\t}\n\t\telse if(NUMBER_VEHICLES == 8){\n\t\t\tif(vehicle1Reached == true && vehicle2Reached == true && vehicle3Reached == true \n\t\t\t&& vehicle4Reached == true && vehicle5Reached == true && vehicle6Reached == true \n\t\t\t&& vehicle7Reached == true && vehicle8Reached == true)\n\t\t\t\tassertion(false);\n\t\t}\n\t}\n\tmsgsrv loop (){\n\t\tself.loop() after(5000);\n\t}\n}\n\nreactiveclass WheelLoader (14) {\n\tknownrebecs\n\t{\n\t\tSegment firstSubSegWlToSc;\n\t}\n\tstatevars\n\t{\n\t\tboolean isLoading;\n\t}\n\tWheelLoader()\n\t{ \n\t\tisLoading = false;\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId){\n\t \tif (isLoading == false){\n\t\t\tisLoading = true;\n\t\t\t((Segment)sender).getPermision(vehicleId);\n\t\t}\n\t\telse \n\t\t\t((Segment)sender).segmentNotFree(vehicleId);\n\t}\t\n\tmsgsrv vehicleEntered(int vehicleId){\n\t\tdelay(LOADING_TIME_WL);\n\t\tself.startSendingToNext(vehicleId);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tfirstSubSegWlToSc.givePermisionForVehicle(vehicleId,-1);\n\t}\n\tmsgsrv getPermision (int vehicleId){\n\t\tisLoading= false;\n\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree (int vehicleId){\n\t\tself.startSendingToNext(vehicleId) after(RESENDING_PERIOD);\n\t}\n}\n\nreactiveclass Segment(14) {\n\tknownrebecs\n\t{\n\t\t\n\t}\n\tstatevars\n\t{\n\t\tboolean isFree;\n\t\tboolean stoppedVehicle;\n\t\tint vehicleSpeed;\t\t\t// speed of the current vehicle\n\t\tint segmentLength;\n\t\t\n\t\tSegment nextSegment;\n\t\tDecisionStation decisionS;\n\t\tPrimaryCrusher primaryC;\n\t\tSecondaryCrusher secondaryC;\n\t\tWheelLoader wheelL;\n\t\tPrePoint prePoint;\n\t\tCrossController crossCtrl;\n\t\tSegment segRequestingCross;\n\t}\n\tSegment(Segment nextS, WheelLoader wl, PrimaryCrusher pc, SecondaryCrusher sc, \n\t\t\t\tDecisionStation ds, PrePoint preCs, CrossController ctrl, int speed, int segLength)\n\t{ \n\t\tnextSegment = nextS;\n\t\tdecisionS = ds;\n\t\tprimaryC = pc;\n\t\tsecondaryC = sc;\n\t\twheelL = wl;\n\t\tprePoint = preCs;\t\n\t\tcrossCtrl = ctrl;\n\t\tsegRequestingCross = null;\n\t\tsegmentLength = segLength;\n\t\t\n\t\tvehicleSpeed = speed;\n\t\tisFree = true;\n\t\tstoppedVehicle =false;\n\t}\n\tmsgsrv givePermisionForVehicle(int vehicleId, int segmentDes){\n\t\tif (isFree)\n\t\t{\n\t\t\tisFree=false;\n\t\t\tif(crossCtrl == null){\n\t\t\t\tif(sender instanceof Segment)\n\t\t\t\t\t((Segment)sender).getPermision(vehicleId);\n\t\t\t\telse if(sender instanceof DecisionStation)\n\t\t\t\t\t((DecisionStation)sender).getPermision(vehicleId);\n\t\t\t\telse if(sender instanceof PrimaryCrusher)\n\t\t\t\t\t((PrimaryCrusher)sender).getPermision(vehicleId);\n\t\t\t\telse if(sender instanceof WheelLoader)\n\t\t\t\t\t((WheelLoader)sender).getPermision(vehicleId);\n\t\t\t\telse if(sender instanceof SecondaryCrusher)\n\t\t\t\t\t((SecondaryCrusher)sender).getPermision(vehicleId);\n\t\t\t\telse if(sender instanceof PrePoint)\n\t\t\t\t\t((PrePoint)sender).getPermision(vehicleId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegRequestingCross = ((Segment)sender);\n\t\t\t\tcrossCtrl.giveCrossPermission(vehicleId);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(sender instanceof Segment)\n\t\t\t\t((Segment)sender).segmentNotFree(vehicleId);\n\t\t\telse if(sender instanceof DecisionStation)\n\t\t\t\t((DecisionStation)sender).segmentNotFree(vehicleId, segmentDes);\n\t\t\telse if(sender instanceof PrimaryCrusher)\n\t\t\t\t((PrimaryCrusher)sender).segmentNotFree(vehicleId);\n\t\t\telse if(sender instanceof WheelLoader)\n\t\t\t\t((WheelLoader)sender).segmentNotFree(vehicleId);\n\t\t\telse if(sender instanceof SecondaryCrusher)\n\t\t\t\t((SecondaryCrusher)sender).segmentNotFree(vehicleId);\n\t\t\telse if(sender instanceof PrePoint)\n\t\t\t\t((PrePoint)sender).segmentNotFree(vehicleId);\n\t\t}\n\t\n\t}\n\tmsgsrv getCrossPermission(int vehicleId){\n\t\t((Segment)segRequestingCross).getPermision(vehicleId);\n\t}\n\tmsgsrv vehicleEntered (int vehicleId){\t// moving of vehicle inside the segment should be modeled\n\t\tdelay((segmentLength-SAFE_DISTANCE)/vehicleSpeed);\n\t\tself.startSendingToNext(vehicleId);\n\t}\n\tmsgsrv crossNotAvailable(int vehicleId){\n\t\tisFree = true;\n\t\t((Segment)segRequestingCross).segmentNotFree(vehicleId);\n\t}\n\tmsgsrv startSendingToNext(int vehicleId){\n\t\tif(nextSegment != null)\n\t\t\tnextSegment.givePermisionForVehicle(vehicleId,-1);\n\t\telse if(primaryC != null)\n\t\t\tprimaryC.givePermisionForVehicle(vehicleId);\n\t\telse if(wheelL != null)\n\t\t\twheelL.givePermisionForVehicle(vehicleId);\n\t\telse if(secondaryC != null)\n\t\t\tsecondaryC.givePermisionForVehicle(vehicleId);\n\t\telse if(decisionS != null)\n\t\t\tdecisionS.givePermisionForVehicle(vehicleId);\n\t\telse if(prePoint != null)\n\t\t\tprePoint.givePermisionForVehicle(vehicleId);\n\t\t\t\n\t}\n\tmsgsrv getPermision (int vehicleId){\n\t\tstoppedVehicle = false;\n\t\tdelay(SAFE_DISTANCE/vehicleSpeed);\n\t\tisFree = true;\n\t\tif(crossCtrl != null){\n\t\t\tsegRequestingCross = null;\n\t\t\tcrossCtrl.freeCross(vehicleId);\n\t\t}\n\t\tif(sender instanceof Segment)\n\t\t\t((Segment)sender).vehicleEntered(vehicleId);\n\t\telse if(sender instanceof DecisionStation)\n\t\t\t((DecisionStation)sender).vehicleEntered(vehicleId);\n\t\telse if(sender instanceof PrimaryCrusher)\n\t\t\t((PrimaryCrusher)sender).vehicleEntered(vehicleId);\n\t\telse if(sender instanceof WheelLoader)\n\t\t\t((WheelLoader)sender).vehicleEntered(vehicleId);\n\t\telse if(sender instanceof SecondaryCrusher)\n\t\t\t((SecondaryCrusher)sender).vehicleEntered(vehicleId);\n\t\telse if(sender instanceof PrePoint)\n\t\t\t((PrePoint)sender).vehicleEntered(vehicleId);\n\t}\n\tmsgsrv segmentNotFree(int vehicleId){\n\t\tstoppedVehicle = true;\n\t\tself.startSendingToNext(vehicleId) after(RESENDING_PERIOD);\n\t}\n}\n\n\nmain{\n\t//************* E1:WL, E2:PC, E3:SC, E4:DP ***********\n\tPrimaryCrusher pc(subSeg1E2ToS2):();\n\tSecondaryCrusher sc(subSeg1E3ToE4):();\n\tWheelLoader wl(subSeg1E1ToS2):();\n\tDecisionStation ds(subSeg1S4ToPre):();\n\tCrossController controller():();\n\tPrePoint prePoint(subSeg1S5ToE1,subSeg1S6ToE2):();\n\t// ():(segment,E1,E2,E3,E4,prepoint,controller)\n\t\n\t//################ S1 ##################\n\tSegment subSeg1E2ToS2():(subSeg2E2ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH); \n\tSegment subSeg2E2ToS2():(subSeg3E2ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3E2ToS2():(subSeg4E2ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4E2ToS2():(subSeg5E2ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5E2ToS2():(subSeg1S2ToE3,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH); \n\t\n\t//##################### S7 ##############\n\tSegment subSeg1E1ToS2():(subSeg2E1ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2E1ToS2():(subSeg3E1ToS2,null,null,null,null,null,controller,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3E1ToS2():(subSeg4E1ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4E1ToS2():(subSeg5E1ToS2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5E1ToS2():(subSeg1S2ToE3,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\t\n\t//################## S2 ################\n\tSegment subSeg1S2ToE3():(subSeg2S2ToE3,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2S2ToE3():(subSeg3S2ToE3,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3S2ToE3():(subSeg4S2ToE3,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4S2ToE3():(subSeg5S2ToE3,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5S2ToE3():(null,null,null,sc,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\t\n\t//################## S3 #############\n\tSegment subSeg1E3ToE4():(subSeg2E3ToE4,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2E3ToE4():(subSeg3E3ToE4,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3E3ToE4():(subSeg4E3ToE4,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4E3ToE4():(subSeg5E3ToE4,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5E3ToE4():(null,null,null,null,ds,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\t\n\t//################## S6 #############\n\tSegment subSeg1S6ToE2():(subSeg2S6ToE2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2S6ToE2():(subSeg3S6ToE2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3S6ToE2():(subSeg4S6ToE2,null,null,null,null,null,controller,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4S6ToE2():(subSeg5S6ToE2,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5S6ToE2():(null,null,pc,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\t\n\t//################## S5 #############\n\tSegment subSeg1S5ToE1():(subSeg2S5ToE1,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2S5ToE1():(subSeg3S5ToE1,null,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3S5ToE1():(null,wl,null,null,null,null,null,REDUCED_SPEED,SEGMENT_LENGTH);\n\t\n\t//################## S4 #############\n\tSegment subSeg1S4ToPre():(subSeg2S4ToPre,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg2S4ToPre():(subSeg3S4ToPre,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg3S4ToPre():(subSeg4S4ToPre,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg4S4ToPre():(subSeg5S4ToPre,null,null,null,null,null,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\tSegment subSeg5S4ToPre():(null,null,null,null,null,prePoint,null,NORMAL_SPEED,SEGMENT_LENGTH);\n\t\n}"
      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
//    "a" -> ""
//      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
//    "a" -> ""
//      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
//    "a" -> ""
//      -> "From <a href=\"http://rebeca-lang.org/Rebeca\">http://rebeca-lang.org/Rebeca</a>.",
  )

  object HistorySOS:
    def apply[Act,State](sos:SOS[Act,State]): SOS[Act,(State,List[Act])] = new SOS:
      type HState = (State,List[Act])
      // generic
      def next[A>:Act](s:HState): Set[(A,HState)] =
        for (a,s2) <- sos.next(s._1) yield a -> (s2,a :: s._2)

    // just for our states
    def toMermaidSnd(hs: (St, List[Act])): String = "sequenceDiagram\n" +
      (for st <- hs._1._2.toList.sortWith(_._1 < _._1) yield s"  ${st._1} ->> ${st._1}: initial(...)").mkString("\n") +
      "\n" +
      (for act <- hs._2.reverse; m <- act._2.toList
        yield s"  ${getFrom(m)} ->> ${getTo(m)}: ${getMsg(m)}${getTime(m)}").mkString("\n")

    def toMermaidRcv(hs:(St,List[Act])):String = "sequenceDiagram\n" +
      (for act <- hs._2.reverse yield s"  ${getFrom(act._1)} ->> ${getTo(act._1)}: ${
          getMsg(act._1)}${getTime(act._1)}").mkString("\n")

    private def getTo(a:Msg): String = a.rcv//"[^.]*".r.findFirstIn(a).getOrElse("X")
    private def getFrom(a:Msg): String = //"@[^ \t\n]*".r.findFirstIn(a).getOrElse("@"+getTo(a)).drop(1)
      if a.snd.isBlank then getTo(a) else a.snd
    private def getMsg(a:Msg): String = s"${a.m}(${a.args.mkString(",")})"//"\\.[^@]*".r.findFirstIn(a).getOrElse(".Z").drop(1)
    private def getTime(a:Msg): String = //".*".r.findFirstIn(a).getOrElse("Z").drop(1)
      (a.tt,a.dl) match
        case (0,None) => ""
        case (i,None) => s" @ $i"
        case (i,Some(dl)) => s" @ $i..$dl"


  /** Description of the widgets that appear in the dashboard. */
  val widgets = List(
    "View pretty data" -> view[St](s=>Show(s._1), Code("haskell")).moveTo(0),
//    "View structure" -> view(Show.mermaid, Mermaid),
     "Run semantics St" -> steps((e:St)=>e, Semantics, Show.apply, a=>Show(a._1), Text).expand,
//     "Run semantics2" -> steps((e:St)=>(e,List[Act]()), HistorySOS(Semantics), st=>s"${Show(st._1)}\n${st._2.reverse.mkString(" > ")}", a=>Show(a._1), Text),
     "Run semantics Snd" -> steps((e:St)=>(e,List[Act]()), HistorySOS(Semantics), HistorySOS.toMermaidSnd, act=>Show(act._1), Mermaid),
     "Run semantics Rcv" -> steps((e:St)=>(e,List[Act]()), HistorySOS(Semantics), HistorySOS.toMermaidRcv, act=>Show(act._1), Mermaid),
     "Build LTS" -> lts((e:St)=>e, Semantics, Show.short, _.toString,50),
     "Build LTS (explore)" -> ltsExplore(e=>e, Semantics, Show.short, _.toString),
//     "Global LTS info" -> view((e: St) => {
//        val (st, eds, done) = SOS.traverse(Semantics, e, 2000)
//        s"States: ${st.size}\nEdges: $eds"+
//          (if !done then "\n(limit of states reached)" else "")
//      },
//      Text),
     "Number of states and edges" -> view((e: St) => {
        val (st, eds, done) = SOS.traverseEdges(Semantics, e, 3000)
        s"States: ${st.size}\nEdges: $eds"+
          (if !done then "\n(stopped: limit of edges reached)" else "")
      },
      Text),
//    "Find strong bisimulation (given a program \"A ~ B\")" ->
//      compareStrongBisim(Semantics, Semantics,
//        (e: System) => System(e.defs, e.main, None),
//        (e: System) => System(e.defs, e.toCompare.getOrElse(Program.Term.End), None),
//        Show.justTerm, Show.justTerm, _.toString),
  )

  //// Documentation below

  override val footer: String =
    """Simple animator of rebecaOS, meant to exemplify the
      | CAOS libraries, used to generate this website. Source code available online:
      | <a target="_blank" href="https://github.com/arcalab/CAOS">
      | https://github.com/arcalab/CAOS</a> (CAOS).""".stripMargin

  private val sosRules: String =
    """The operational rules that we use to reduce programs are provided below.
      |These are explained, e.g. in
      |<a href="http://dx.doi.org/10.1016/j.scico.2014.07.005" target="_blank">this SCP publication (2014)</a>.
      |<pre>
      |WHEN
      |  (_ri(m), // statement
      |   _ri[now=max(TT,_ri(now)),[arg=v],sender=rj], // env
      |   Env,    // USELESS
      |   B)      // outgoing messages // NOT NEEDED here
      |  EVALUATES TO
      |  ('_ri,   // new env
      |   Env',   // ALWAYS Env (without dynamic "new" creation)
      |   B')     // new/updated outgoing messages
      |IF
      |  TTmin(B) 
      |  _ri(now)DL 
      |  (ri,m(v),rj,TT,DL) notin B 
      |  _ri notin Env
      |THEN
      |  ({ri}Env,
      |   {(ri,m(v),rj,TT,DL)}B)
      |  
      |  ({'_ri}  Env',
      |   B')
      |</pre>""".stripMargin

  override val documentation: Documentation = List(
    languageName -> "More information on the syntax of rebecaOS" ->
      """The syntax and timed (static) semantics for a Rebeca program can be found, e.g., in
        |<a href="http://dx.doi.org/10.1016/j.scico.2014.07.005" target="_blank">this SCP publication (2014)</a>.
        |""".stripMargin,
    "Build LTS" -> "More information on the operational rules used here" -> sosRules,
    "Build LTS (explore)" -> "More information on the operational rules used here" -> sosRules,
    "Run semantics" -> "More information on the operational rules used here" -> sosRules,
  )
